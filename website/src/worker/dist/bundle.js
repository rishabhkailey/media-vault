/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/ts-chacha20/build/src/chacha20.js":
/*!************************************************************!*\
  !*** ../../node_modules/ts-chacha20/build/src/chacha20.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright (c) 2017, Bubelich Mykola\n * https://www.bubelich.com\n *\n * (｡◕‿‿◕｡)\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met, 0x\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * Neither the name of the copyright holder nor the names of its contributors\n * may be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * ChaCha20 is a stream cipher designed by D. J. Bernstein.\n * It is a refinement of the Salsa20 algorithm, and it uses a 256-bit key.\n *\n * ChaCha20 successively calls the ChaCha20 block function, with the same key and nonce, and with successively increasing block counter parameters.\n * ChaCha20 then serializes the resulting state by writing the numbers in little-endian order, creating a keystream block.\n *\n * Concatenating the keystream blocks from the successive blocks forms a keystream.\n * The ChaCha20 function then performs an XOR of this keystream with the plaintext.\n * Alternatively, each keystream block can be XORed with a plaintext block before proceeding to create the next block, saving some memory.\n * There is no requirement for the plaintext to be an integral multiple of 512 bits.  If there is extra keystream from the last block, it is discarded.\n *\n * The inputs to ChaCha20 are\n * - 256-bit key\n * - 32-bit initial counter\n * - 96-bit nonce.  In some protocols, this is known as the Initialization Vector\n * - Arbitrary-length plaintext\n *\n * Implementation derived from chacha-ref.c version 20080118\n * See for details, 0x http, 0x//cr.yp.to/chacha/chacha-20080128.pdf\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Chacha20 = void 0;\n/**\n *\n * @param {Uint8Array} key\n * @param {Uint8Array} nonce\n * @param {number} counter\n * @throws {Error}\n *\n * @constructor\n */\nvar Chacha20 = /** @class */ (function () {\n    function Chacha20(key, nonce, counter) {\n        this.key = key;\n        this.nonce = nonce;\n        this.counter = counter;\n        this._rounds = 20;\n        // Constants\n        this._sigma = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574];\n        // internal byte counter //\n        this._byteCounter = 0;\n        if (!(key instanceof Uint8Array) || key.length !== 32) {\n            throw new Error('Key should be 32 byte array!');\n        }\n        if (!(nonce instanceof Uint8Array) || nonce.length !== 12) {\n            throw new Error('Nonce should be 12 byte array!');\n        }\n        if (!counter) {\n            this.counter = 0;\n        }\n        // param construction\n        this._param = [\n            this._sigma[0],\n            this._sigma[1],\n            this._sigma[2],\n            this._sigma[3],\n            // key\n            this._get32(key, 0),\n            this._get32(key, 4),\n            this._get32(key, 8),\n            this._get32(key, 12),\n            this._get32(key, 16),\n            this._get32(key, 20),\n            this._get32(key, 24),\n            this._get32(key, 28),\n            // counter\n            this.counter,\n            // nonce\n            this._get32(nonce, 0),\n            this._get32(nonce, 4),\n            this._get32(nonce, 8)\n        ];\n        // init 64 byte keystream block //\n        this._keystream = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n    }\n    Chacha20.prototype._chacha = function () {\n        var mix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        var i = 0;\n        var b = 0;\n        // copy param array to mix //\n        for (i = 0; i < 16; i++) {\n            mix[i] = this._param[i];\n        }\n        // mix rounds //\n        for (i = 0; i < this._rounds; i += 2) {\n            this._quarterround(mix, 0, 4, 8, 12);\n            this._quarterround(mix, 1, 5, 9, 13);\n            this._quarterround(mix, 2, 6, 10, 14);\n            this._quarterround(mix, 3, 7, 11, 15);\n            this._quarterround(mix, 0, 5, 10, 15);\n            this._quarterround(mix, 1, 6, 11, 12);\n            this._quarterround(mix, 2, 7, 8, 13);\n            this._quarterround(mix, 3, 4, 9, 14);\n        }\n        for (i = 0; i < 16; i++) {\n            // add\n            mix[i] += this._param[i];\n            // store keystream\n            this._keystream[b++] = mix[i] & 0xFF;\n            this._keystream[b++] = (mix[i] >>> 8) & 0xFF;\n            this._keystream[b++] = (mix[i] >>> 16) & 0xFF;\n            this._keystream[b++] = (mix[i] >>> 24) & 0xFF;\n        }\n    };\n    /**\n     * The basic operation of the ChaCha algorithm is the quarter round.\n     * It operates on four 32-bit unsigned integers, denoted a, b, c, and d.\n     *\n     * @param {Array} output\n     * @param {number} a\n     * @param {number} b\n     * @param {number} c\n     * @param {number} d\n     * @private\n     */\n    Chacha20.prototype._quarterround = function (output, a, b, c, d) {\n        output[d] = this._rotl(output[d] ^ (output[a] += output[b]), 16);\n        output[b] = this._rotl(output[b] ^ (output[c] += output[d]), 12);\n        output[d] = this._rotl(output[d] ^ (output[a] += output[b]), 8);\n        output[b] = this._rotl(output[b] ^ (output[c] += output[d]), 7);\n        // JavaScript hack to make UINT32 :) //\n        output[a] >>>= 0;\n        output[b] >>>= 0;\n        output[c] >>>= 0;\n        output[d] >>>= 0;\n    };\n    /**\n     * Little-endian to uint 32 bytes\n     *\n     * @param {Uint8Array|[number]} data\n     * @param {number} index\n     * @return {number}\n     * @private\n     */\n    Chacha20.prototype._get32 = function (data, index) {\n        return data[index++] ^ (data[index++] << 8) ^ (data[index++] << 16) ^ (data[index] << 24);\n    };\n    /**\n     * Cyclic left rotation\n     *\n     * @param {number} data\n     * @param {number} shift\n     * @return {number}\n     * @private\n     */\n    Chacha20.prototype._rotl = function (data, shift) {\n        return ((data << shift) | (data >>> (32 - shift)));\n    };\n    /**\n     *  Encrypt data with key and nonce\n     *\n     * @param {Uint8Array} data\n     * @return {Uint8Array}\n     */\n    Chacha20.prototype.encrypt = function (data) {\n        return this._update(data);\n    };\n    /**\n     *  Decrypt data with key and nonce\n     *\n     * @param {Uint8Array} data\n     * @return {Uint8Array}\n     */\n    Chacha20.prototype.decrypt = function (data) {\n        return this._update(data);\n    };\n    /**\n     *  Encrypt or Decrypt data with key and nonce\n     *\n     * @param {Uint8Array} data\n     * @return {Uint8Array}\n     * @private\n     */\n    Chacha20.prototype._update = function (data) {\n        if (!(data instanceof Uint8Array) || data.length === 0) {\n            throw new Error('Data should be type of bytes (Uint8Array) and not empty!');\n        }\n        var output = new Uint8Array(data.length);\n        // core function, build block and xor with input data //\n        for (var i = 0; i < data.length; i++) {\n            if (this._byteCounter === 0 || this._byteCounter === 64) {\n                // generate new block //\n                this._chacha();\n                // counter increment //\n                this._param[12]++;\n                // reset internal counter //\n                this._byteCounter = 0;\n            }\n            output[i] = data[i] ^ this._keystream[this._byteCounter++];\n        }\n        return output;\n    };\n    return Chacha20;\n}());\nexports.Chacha20 = Chacha20;\n//# sourceMappingURL=chacha20.js.map\n\n//# sourceURL=webpack:///../../node_modules/ts-chacha20/build/src/chacha20.js?");

/***/ }),

/***/ "../utils/request.ts":
/*!***************************!*\
  !*** ../utils/request.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseResponseRangeHeader = exports.parseRequestRangeHeader = void 0;\nfunction parseRequestRangeHeader(range) {\n    var parts = range.split(\"=\");\n    if (parts.length != 2) {\n        throw new Error(\"Invalid range header \" + range);\n    }\n    var unit = parts[0];\n    var rangePart = parts[1];\n    var end = -1;\n    if (rangePart.split(\"-\").length === 2 &&\n        rangePart.split(\"-\")[1].length !== 0) {\n        end = Number(rangePart.split(\"-\")[1]);\n    }\n    var start = Number(rangePart.split(\"-\")[0]);\n    return {\n        unit: unit,\n        start: start,\n        end: end,\n    };\n}\nexports.parseRequestRangeHeader = parseRequestRangeHeader;\nfunction parseResponseRangeHeader(range) {\n    var parts = range.split(\" \");\n    if (parts.length != 2) {\n        throw new Error(\"Invalid range header \" + range);\n    }\n    var unit = parts[0];\n    // rangeSizePart = 200-1000/67589\n    var rangeSizePart = parts[1];\n    parts = rangeSizePart.split(\"/\");\n    if (parts.length != 2) {\n        throw new Error(\"Invalid range header \" + range);\n    }\n    var size = Number(parts[1]);\n    // rangePart = 200-1000\n    var rangePart = parts[0];\n    if (rangePart.split(\"-\").length != 2) {\n        throw new Error(\"Invalid range header \" + range);\n    }\n    var start = Number(rangePart.split(\"-\")[0]);\n    var end = Number(rangePart.split(\"-\")[1]);\n    return {\n        unit: unit,\n        start: start,\n        end: end,\n        size: size,\n    };\n}\nexports.parseResponseRangeHeader = parseResponseRangeHeader;\n\n\n//# sourceURL=webpack:///../utils/request.ts?");

/***/ }),

/***/ "./decrypt.ts":
/*!********************!*\
  !*** ./decrypt.ts ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ts_chacha20_1 = __webpack_require__(/*! ts-chacha20 */ \"../../node_modules/ts-chacha20/build/src/chacha20.js\");\nvar request_1 = __webpack_require__(/*! ../utils/request */ \"../utils/request.ts\");\n// const sw = self as ServiceWorkerGlobalScope & typeof globalThis;\nself.addEventListener(\"install\", function () {\n    self.skipWaiting();\n});\nself.addEventListener(\"activate\", function (event) {\n    event.waitUntil(self.clients.claim());\n});\nvar map = new Map();\n// This should be called once per download\n// Each event has a dataChannel that the data will be piped through\nself.onmessage = function (event) {\n    // We send a heartbeat every x second to keep the\n    // service worker alive if a transferable stream is not sent\n    if (event.data === \"ping\") {\n        return;\n    }\n    var data = event.data;\n    var downloadUrl = data.url ||\n        self.registration.scope +\n            Math.random() +\n            \"/\" +\n            (typeof data === \"string\" ? data : data.filename);\n    var port = event.ports[0];\n    var metadata = new Array(3); // [stream, data, port]\n    metadata[1] = data;\n    metadata[2] = port;\n    // Note to self:\n    // old streamsaver v1.2.0 might still use `readableStream`...\n    // but v2.0.0 will always transfer the stream through MessageChannel #94\n    if (event.data.readableStream) {\n        metadata[0] = event.data.readableStream;\n    }\n    else if (event.data.transferringReadable) {\n        port.onmessage = function (evt) {\n            port.onmessage = null;\n            metadata[0] = evt.data.readableStream;\n        };\n    }\n    else {\n        metadata[0] = createStream(port);\n    }\n    map.set(downloadUrl, metadata);\n    port.postMessage({ download: downloadUrl });\n};\nfunction createStream(port) {\n    // ReadableStream is only supported by chrome 52\n    return new ReadableStream({\n        start: function (controller) {\n            // When we receive data on the messageChannel, we write\n            port.onmessage = function (_a) {\n                var data = _a.data;\n                if (data === \"end\") {\n                    return controller.close();\n                }\n                if (data === \"abort\") {\n                    controller.error(\"Aborted the download\");\n                    return;\n                }\n                controller.enqueue(data);\n            };\n        },\n        cancel: function (reason) {\n            console.log(\"user aborted\", reason);\n            port.postMessage({ abort: true });\n        },\n    });\n}\nvar newDecryptTransformer = function (decryptor) {\n    return new TransformStream({\n        start: function () { },\n        transform: function (chunk, controller) {\n            if (!chunk) {\n                console.log(\"undefined chunk\");\n            }\n            // console.log(\"encrypted \", new TextDecoder().decode(chunk));\n            var decryptedChunk = decryptChunk(chunk, decryptor);\n            // console.log(\"decrypted \", new TextDecoder().decode(decryptedChunk));\n            controller.enqueue(decryptedChunk);\n        },\n        flush: function () { },\n    });\n};\nvar decryptChunk = function (input, decryptor) {\n    try {\n        var decrypted = decryptor.decrypt(input);\n        if (!(decrypted === null || decrypted === void 0 ? void 0 : decrypted.length) || decrypted.length !== input.length) {\n            console.log(decrypted);\n        }\n        // console.log(new TextDecoder().decode(decrypted));\n        return decrypted;\n    }\n    catch (err) {\n        console.log(err);\n    }\n    return new Uint8Array(0);\n};\nfunction internalFetch(req) {\n    return __awaiter(this, void 0, void 0, function () {\n        var rangeHeader, range, password, nonce, useless, i, counter, byteCounter, textEncoder, decryptor, res, encryptedStream, decryptedStream, err_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    rangeHeader = req.headers.get(\"Range\");\n                    if (rangeHeader !== null && rangeHeader.length !== 0) {\n                        range = (0, request_1.parseRequestRangeHeader)(rangeHeader);\n                    }\n                    else {\n                        // todo\n                    }\n                    password = \"01234567890123456789012345678901\";\n                    nonce = \"012345678901\";\n                    useless = new TextEncoder().encode(\"00000000000000000000000000000000000000000000000000000000000000000\");\n                    i = 0;\n                    if ((range === null || range === void 0 ? void 0 : range.start) !== undefined) {\n                        i = range.start;\n                    }\n                    counter = Math.floor(i / 64);\n                    byteCounter = i % 64;\n                    textEncoder = new TextEncoder();\n                    decryptor = new ts_chacha20_1.Chacha20(textEncoder.encode(password), textEncoder.encode(nonce), counter);\n                    // set the internal byte counter\n                    if (byteCounter !== 0) {\n                        decryptor.decrypt(useless.slice(0, byteCounter));\n                    }\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, fetch(req)];\n                case 2:\n                    res = _a.sent();\n                    encryptedStream = res.body;\n                    if (encryptedStream === null) {\n                        return [2 /*return*/, new Response(\"res\")];\n                    }\n                    decryptedStream = encryptedStream.pipeThrough(newDecryptTransformer(decryptor));\n                    // console.log(rangeHeader, range);\n                    // console.log(req);\n                    // const blob = await new Response(decryptedStream).blob();\n                    // console.log(await blob.text());\n                    // console.log(res.headers.get(\"Content-Type\"));\n                    return [2 /*return*/, new Response(decryptedStream, {\n                            headers: res.headers,\n                            status: res.status,\n                            statusText: res.statusText,\n                        })];\n                case 3:\n                    err_1 = _a.sent();\n                    console.log(err_1);\n                    return [2 /*return*/, new Response(undefined, {\n                            status: 500,\n                        })];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nself.onfetch = function (event) {\n    var _a, _b;\n    var url = event.request.url;\n    // this only works for Firefox\n    if (url.endsWith(\"/ping\")) {\n        return event.respondWith(new Response(\"pong\"));\n    }\n    var urlObj = new URL(url);\n    if (((_a = event === null || event === void 0 ? void 0 : event.request) === null || _a === void 0 ? void 0 : _a.method) === \"GET\" &&\n        typeof ((_b = event === null || event === void 0 ? void 0 : event.request) === null || _b === void 0 ? void 0 : _b.url) === \"string\" &&\n        (urlObj.pathname.startsWith(\"/v1/media/\") ||\n            urlObj.pathname.startsWith(\"/v1/thumbnail/\"))\n    // new URL(event.request.url).pathname.startsWith(\"/v1/testGetVideoWithRange\")\n    ) {\n        return event.respondWith(internalFetch(event.request));\n        // fetch(event.request)\n        //   .then((res) => {\n        //     const encryptedStream = res.body;\n        //     if (encryptedStream === null) {\n        //       return event.respondWith(res);\n        //     }\n        //     const decryptedStream = encryptedStream.pipeThrough(\n        //       newDecryptTransformer()\n        //     );\n        //     return event.respondWith(\n        //       new Response(decryptedStream, {\n        //         headers: res.headers,\n        //         status: res.status,\n        //         statusText: res.statusText,\n        //       })\n        //     );\n        //   })\n        //   .catch((err) => {\n        //     console.log(err);\n        //     return event.respondWith(\n        //       new Response(\"decryption failed\", {\n        //         status: 500,\n        //       })\n        //     );\n        //   });\n        // console.log(rangeHeader, range);\n        // console.log(event?.request);\n    }\n    var hijacke = map.get(url);\n    if (!hijacke) {\n        return null;\n    }\n    var stream = hijacke[0], data = hijacke[1], port = hijacke[2];\n    map.delete(url);\n    // Not comfortable letting any user control all headers\n    // so we only copy over the length & disposition\n    var responseHeaders = new Headers({\n        \"Content-Type\": \"application/octet-stream; charset=utf-8\",\n        // To be on the safe side, The link can be opened in a iframe.\n        // but octet-stream should stop it.\n        \"Content-Security-Policy\": \"default-src 'none'\",\n        \"X-Content-Security-Policy\": \"default-src 'none'\",\n        \"X-WebKit-CSP\": \"default-src 'none'\",\n        \"X-XSS-Protection\": \"1; mode=block\",\n    });\n    var headers = new Headers(data.headers || {});\n    {\n        var contentLength = headers.get(\"Content-Length\");\n        if (contentLength != null) {\n            responseHeaders.set(\"Content-Length\", contentLength);\n        }\n    }\n    {\n        var contentDisposition = headers.get(\"Content-Disposition\");\n        if (contentDisposition != null) {\n            responseHeaders.set(\"Content-Disposition\", contentDisposition);\n        }\n    }\n    // data, data.filename and size should not be used anymore\n    if (data.size) {\n        console.warn(\"Depricated\");\n        responseHeaders.set(\"Content-Length\", data.size);\n    }\n    var fileName = typeof data === \"string\" ? data : data.filename;\n    if (fileName) {\n        console.warn(\"Depricated\");\n        // Make filename RFC5987 compatible\n        fileName = encodeURIComponent(fileName)\n            .replace(/['()]/g, escape)\n            .replace(/\\*/g, \"%2A\");\n        responseHeaders.set(\"Content-Disposition\", \"attachment; filename*=UTF-8''\" + fileName);\n    }\n    event.respondWith(new Response(stream, { headers: responseHeaders }));\n    port.postMessage({ debug: \"Download started\" });\n};\n// // export const onmessage = function (event) {\n// //   console.log(\"message received\", event)\n// // };\n// import sodium from \"libsodium-wrappers\";\n// self.addEventListener(\"message\", (message) => {\n//   console.log(\"message received\", message);\n//   // postMessage(\"sending response\" + message.data);\n// });\n// self.addEventListener(\"install\", function (event) {\n//   console.log(\"install\");\n// });\n// self.addEventListener(\"activate\", function (event) {\n//   console.log(\"Claiming control\");\n//   return self.clients.claim();\n// });\n// let password = \"berrysikure\";\n// const decrypt: (input: Uint8Array) => Uint8Array = (input) => {\n//   if (password.length == 0) {\n//     throw new Error(\"password length zero\");\n//   }\n//   while (password.length < 32) {\n//     password += password;\n//   }\n//   password = password.substring(0, 32);\n//   const encoder = new TextEncoder();\n//   const key = encoder.encode(password);\n//   console.log(sodium);\n//   const res = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);\n//   const state_in = sodium.crypto_secretstream_xchacha20poly1305_init_pull(\n//     res.header,\n//     key\n//   );\n//   const output = sodium.crypto_secretstream_xchacha20poly1305_pull(\n//     state_in,\n//     input\n//   );\n//   return output.message;\n// };\n// self.addEventListener(\"fetch\", (event: any) => {\n//   if (\n//     event?.request?.method !== \"GET\" ||\n//     (typeof event?.request?.url === \"string\" &&\n//       !new URL(event.request.url).pathname.startsWith(\"/v1/testGetEncryptedVideoWithRange\"))\n//   ) {\n//     return;\n//   }\n//   console.log(\"fetch event\", event);\n//   event.respondWith(\n//     fetch(event.request).then(async function (response) {\n//       while (password.length < 32) {\n//         password += password;\n//       }\n//       password = password.substring(0, 32);\n//       // console.log(response);\n//       // const reader = response.body?.getReader();\n//       // if (!reader) {\n//       //   console.log(\"unable to get response reader\");\n//       //   return new Response(new Blob([]), {\n//       //     headers: response.headers,\n//       //     status: 500,\n//       //   });\n//       // }\n//       try {\n//         const encryptedBytes = new Uint8Array(await response.arrayBuffer());\n//         await sodium.ready;\n//         const decryptedBytes = decrypt(encryptedBytes);\n//         return new Response(new Blob([decryptedBytes]), {\n//           headers: response.headers,\n//           status: response.status,\n//         });\n//       } catch (err) {\n//         console.log(\"error decyrpting the response\", err);\n//         return new Response(new Blob([]), {\n//           headers: response.headers,\n//           status: 500,\n//         });\n//       }\n//       // new Response()\n//       // return response;\n//       // if(response.url.match(\".mp4\")){\n//       //   console.log(event);\n//       //   responseCloned = response.clone();\n//       //   responseCloned.arrayBuffer().then(\n//       //     buffer =>{\n//       //       let length = 100\n//       //       view = new Uint8Array(buffer,0,length)\n//       //       for(i=0,j=length - 1; i<j; i++,j--){\n//       //           view[i] = view[i] ^ view[j]\n//       //           view[j] = view[j] ^ view[i]\n//       //           view[i] = view[i] ^ view[j]\n//       //       }\n//       //     }\n//       //   )\n//       // }\n//       // return responseCloned;\n//     })\n//   );\n// });\n\n\n//# sourceURL=webpack:///./decrypt.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./decrypt.ts");
/******/ 	
/******/ })()
;