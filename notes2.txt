this will only be used for verifying user? and the user authorization will be handeled by the client?

// case 1
OIDC:
    scopes:
        - email
        - username
        - admin
        - user
Client:
    userAccessScopes:
        - admin
        - user
    resources:
        - id
        - owner
User:


// case 2

AuthService:
    idScopes:
        - email
        - username
    accessScopes:
        - admin
        - user

Client:
    resources:
        - id
        - owner
// how we will verify the owner?, we will need to add custom logic in AuthService which will make point of AuthService being separate and reusable not valid, as every client will need its own logic.


// 2 scopes
1. for user(what access does user have)
2. in for client(what client can do on behalf of user)
client scopes should be subset of user scopes

user, client, auth server, resource server (in our case resource server and client will be same)

client will request some scopes on behalf of user, if user doesn't have access to scopes that client requested 401
else will return access_token



so our auth service should do the following
** think if it as a auth service not oauth
DB
* store client
* possible client scopes (client = client of auth service, think of auth service as a plugable service)
* store user details
* scopes assigned to users
* should users be tied to 1 client? no, right? scope assigned to user should be tied to client
* user cretion with temp password

// how we client will get user data from auth server? create new endpoint of id tokens?

goal shold be to create auth service compatible with oauth and oidc, not to use oidc as auth service that't just not possible

oidc vs oauth2 library


    Client on start
        client > auth server "/.well-known/openid-configuration"
        op.Discover 

    flow of oidc all the function/checks called before returning a token
    http://localhost:9999/login
        client authorization get "/auth?client_id=web&redirect_uri=http%3A%2F%2Flocalhost%3A9999%2Fauth%2Fcallback&response_type=code&scope=openid+profile&state=86bbf34f-6455-42c5-9641-4c09e3cf73e5"
            op.Authorize
                authorizer.Storage().CreateAuthRequest (our function)
                authorizer.Storage().GetClientByClientID (our function)
    login page
        post /username
            if user and password correct
                redirect to callback url
    
        post "/auth/callback?id=27d6af48-0ea5-4570-8a58-5ca8cf26bf38"
            op.AuthorizeCallback
                authReq = authorizer.Storage().AuthRequestByID (our function)
                if !authReq.Done() {
                    AuthRequestError(w, r, authReq,
                        oidc.ErrInteractionRequired().WithDescription("Unfortunately, the user may be not logged in and/or additional interaction is required."),
                        authorizer.Encoder())
                    return
                }

                op.AuthResponse
                    authorizer.Storage().GetClientByClientID (our function)
                    if response type == code (in our case yes)
                    op.AuthResponseCode
                        op.CreateAuthRequestCode
                            code = crypto.Encrypt(authReq.GetID())
                            storage.SaveAuthCode (our function)
                        codeResponse := {
                            code:  code,
                            state: authReq.GetState(),
                        }
                        AuthResponseURL(authReq.GetRedirectURI(), authReq.GetResponseType(), authReq.GetResponseMode(), &codeResponse, authorizer.Encoder())
                        "http://localhost:9999/auth/callback?code=IzrXEYpiUWa26ljXPc1NybUVT7UeZSOh066WVMHuZHPMtomxSnakjueaDn9-ksqNXy-ZOw&state=da43b3d1-312c-400a-8975-9075ef985877"
                        http.Redirect(w, r, callback, http.StatusFound)


    Client calls exchange function
        "/oauth/token"
            op.ValidateAccessTokenRequest
            op.CreateTokenResponse (contains both access token and response token)
            rp.CodeExchangeHandler(rp.UserinfoCallback(<custom-function>), provider)


ResponseTypes:
	// ResponseTypeCode for the Authorization Code Flow returning a code from the Authorization Server
	ResponseTypeCode ResponseType = "code"

	// ResponseTypeIDToken for the Implicit Flow returning id and access tokens directly from the Authorization Server
	ResponseTypeIDToken ResponseType = "id_token token"

	// ResponseTypeIDTokenOnly for the Implicit Flow returning only id token directly from the Authorization Server
	ResponseTypeIDTokenOnly ResponseType = "id_token"

there are some predefined scopes in oidc package authoriztion.go file

GrantTypes:
	// GrantTypeCode defines the grant_type `authorization_code` used for the Token Request in the Authorization Code Flow
	GrantTypeCode GrantType = "authorization_code"

	// GrantTypeRefreshToken defines the grant_type `refresh_token` used for the Token Request in the Refresh Token Flow
	GrantTypeRefreshToken GrantType = "refresh_token"

	// GrantTypeClientCredentials defines the grant_type `client_credentials` used for the Token Request in the Client Credentials Token Flow
	GrantTypeClientCredentials GrantType = "client_credentials"

	// GrantTypeBearer defines the grant_type `urn:ietf:params:oauth:grant-type:jwt-bearer` used for the JWT Authorization Grant
	GrantTypeBearer GrantType = "urn:ietf:params:oauth:grant-type:jwt-bearer"

	// GrantTypeTokenExchange defines the grant_type `urn:ietf:params:oauth:grant-type:token-exchange` used for the OAuth Token Exchange Grant
	GrantTypeTokenExchange GrantType = "urn:ietf:params:oauth:grant-type:token-exchange"

	// GrantTypeImplicit defines the grant type `implicit` used for implicit flows that skip the generation and exchange of an Authorization Code
	GrantTypeImplicit GrantType = "implicit"



scopes related code
    oidc.DiscoveryConfiguration
    oidc.introspectionResponse
    grants
    op.ValidateAuthReqScopes


i don't think custom scopes are possible


next write all requirements/APIs then just add the missing one in oauth2
* new grant type for id and access token(this should not be required)
* new response type for id and access token
* tokenInfo.getScope and tokenInfo.getAceess (get access for access token its not like scopes) (check models.Token)
* s.ClientScopeHandler,s.AccessTokenExpHandler (used in /oauth/authorize handler (after user click allow))
* s.ClientAuthorizedHandler (/oauth/token) (this is for client auth only)
https://github.com/go-oauth2/oauth2/issues/90


all methods that we can override
s.PreRedirectErrorHandler;
s.ResponseTokenHandler; (not of much use, it will write data to response writer. if we want custom data then we can use s.ExtensionFieldsHandler)
s.ClientAuthorizedHandler;
s.ClientScopeHandler; (SetClientScopeHandler check the client allows to use scope, maybe helpful in remebering the permission user allowed)
s.AuthorizeScopeHandler; (SetAuthorizeScopeHandler set scope for the access token)
s.AccessTokenExpHandler; (token expiry)
s.ExtensionFieldsHandler; (add data to token response)
s.InternalErrorHandler;
s.ResponseErrorHandler;

scopes:
    https://gitlab.com/-/profile/personal_access_tokens
    # idTokenScopes:
    - profile
    # access
    - getImage
    - getVideos
    - uploadImages
    - uploadVideos

https://gitlab.com/.well-known/openid-configuration
https://www.ibm.com/docs/en/was-liberty/base?topic=connect-openid-endpoint-urls

let's not go for full oidc for now


endpoint required for oidc

/healthz
/ready
/.well-known/openid-configuration
/oauth/token (obtain access, id and refresh token)
/oauth/introspect (return metadata about access token)
/callback
/authorize 
/userinfo (user info based on the id token)
/revoke 
/end_session (on logout)
/keys (done)

response type - code
grant_types_supported - authorization_code
todo - 
* "password"
* "client_credentials"
* "refresh_token"

https://atlasgo.io/

https://github.com/avelino/awesome-go#authentication-and-oauth
